{
  "task": "Refactorisation complÃ¨te des contrÃ´leurs backend L'Antre",
  "objective": "Remplacer privateStoriesController et publicStoriesController par une architecture 1 service = 1 controller",
  "context": {
    "app": "L'Antre - Plateforme de chroniques/histoires",
    "framework": "Node.js/Express",
    "database": "SQLite avec requÃªtes SQL directes",
    "auth": "JWT middleware authenticateToken",
    "current_architecture": {
      "controllers_to_remove": [
        "privateStoriesController.js",
        "publicStoriesController.js"
      ],
      "controllers_to_keep": [
        "authController.js",
        "userController.js"
      ]
    }
  },
  "new_controllers": {
    "loadController.js": {
      "responsibility": "TOUT le chargement de donnÃ©es",
      "base_route": "/api/load",
      "middleware": "authenticateToken pour routes privÃ©es uniquement",
      "endpoints": [
        {
          "method": "GET",
          "path": "/story/:id",
          "auth": "required",
          "source": "privateStoriesController.getStoryForEdit",
          "purpose": "Charger story pour Ã©dition"
        },
        {
          "method": "GET", 
          "path": "/stats",
          "auth": "required",
          "source": "privateStoriesController.getStats",
          "purpose": "Statistiques utilisateur (drafts, published, totalLikes)"
        },
        {
          "method": "GET",
          "path": "/drafts", 
          "auth": "required",
          "source": "privateStoriesController.getDrafts",
          "purpose": "Liste brouillons utilisateur"
        },
        {
          "method": "GET",
          "path": "/published",
          "auth": "required", 
          "source": "privateStoriesController.getPublishedStories",
          "purpose": "Liste histoires publiÃ©es utilisateur"
        },
        {
          "method": "GET",
          "path": "/resolve/:title",
          "auth": "required",
          "source": "privateStoriesController.resolveTitle", 
          "purpose": "RÃ©soudre titre vers ID story"
        },
        {
          "method": "GET",
          "path": "/latest-stories",
          "auth": "none",
          "source": "publicStoriesController.getLatestStories",
          "purpose": "DerniÃ¨res histoires publiques pour page d'accueil"
        },
        {
          "method": "GET",
          "path": "/public-story/:id",
          "auth": "none", 
          "source": "publicStoriesController.getStoryById",
          "purpose": "Story publique par ID"
        },
        {
          "method": "GET",
          "path": "/user-stories/:userId",
          "auth": "none",
          "source": "publicStoriesController.getUserStories", 
          "purpose": "Toutes les stories d'un utilisateur"
        },
        {
          "method": "GET",
          "path": "/user-profile/:userId",
          "auth": "none",
          "source": "publicStoriesController.getUserProfile",
          "purpose": "Profil public utilisateur"
        },
        {
          "method": "GET", 
          "path": "/resolve-username/:username",
          "auth": "none",
          "source": "publicStoriesController.resolveUsername",
          "purpose": "RÃ©soudre username vers userId"
        },
        {
          "method": "GET",
          "path": "/resolve-story/:username/:title", 
          "auth": "none",
          "source": "publicStoriesController.resolveStory",
          "purpose": "RÃ©soudre username/title vers storyId"
        }
      ]
    },
    "saveController.js": {
      "responsibility": "TOUTE la sauvegarde/modification de donnÃ©es",
      "base_route": "/api/save", 
      "middleware": "authenticateToken sur toutes les routes",
      "endpoints": [
        {
          "method": "POST",
          "path": "/create",
          "source": "privateStoriesController.createDraft",
          "purpose": "CrÃ©er nouveau brouillon"
        },
        {
          "method": "PUT", 
          "path": "/story/:id",
          "source": "privateStoriesController.updateDraft",
          "purpose": "Sauvegarder modifications brouillon"
        },
        {
          "method": "POST",
          "path": "/publish/:id",
          "source": "privateStoriesController.publishStory", 
          "purpose": "Publier brouillon"
        },
        {
          "method": "POST",
          "path": "/update/:id",
          "source": "privateStoriesController.updateOriginalStory",
          "purpose": "Republier story modifiÃ©e"
        },
        {
          "method": "POST",
          "path": "/toggle-like/:id",
          "source": "privateStoriesController.toggleLike",
          "purpose": "Liker/unliker story publique"
        }
      ]
    },
    "deleteController.js": {
      "responsibility": "TOUTE la suppression de donnÃ©es", 
      "base_route": "/api/delete",
      "middleware": "authenticateToken sur toutes les routes",
      "endpoints": [
        {
          "method": "DELETE",
          "path": "/story/:id",
          "source": "privateStoriesController.deleteStory",
          "purpose": "Supprimer story (brouillon ou publiÃ©e)"
        }
      ]
    }
  },
  "technical_specs": {
    "code_style": {
      "quality": "Senior level - simple, robuste, efficace", 
      "separators": "//============ SECTION ============",
      "naming": "Noms logiques, pas d'inventions",
      "error_handling": "try/catch avec messages d'erreur clairs",
      "responses": "Format JSON consistant { message, data, error }",
      "no_logs": "Pas de console.log parasites"
    },
    "route_structure": {
      "pattern": "router.METHOD('/path', middleware, controller.method)",
      "middleware_usage": "authenticateToken uniquement oÃ¹ nÃ©cessaire",
      "parameter_validation": "Validation basique req.params, req.body"
    },
    "database": {
      "type": "postgresq",
      "queries": "ORM PRISMA",
    }
  },
  "migration_steps": {
    "step_1": "CrÃ©er loadController.js avec tous les endpoints de chargement",
    "step_2": "CrÃ©er saveController.js avec tous les endpoints de sauvegarde", 
    "step_3": "CrÃ©er deleteController.js avec endpoint de suppression",
    "step_4": "Mettre Ã  jour les routes dans server.js",
    "step_5": "Tester tous les endpoints",
    "step_6": "Supprimer privateStoriesController.js et publicStoriesController.js"
  },
  "routes_update": {
    "server.js_changes": [
      "app.use('/api/load', require('./routes/load.routes'));",
      "app.use('/api/save', require('./routes/save.routes'));", 
      "app.use('/api/delete', require('./routes/delete.routes'));"
    ],
    "routes_to_remove": [
      "app.use('/api/private-stories', require('./routes/privateStories.routes'));",
      "app.use('/api/public-stories', require('./routes/publicStories.routes'));"
    ]
  },
  "frontend_impact": {
    "services_to_update": [
      "LoadService: Changer URLs vers /api/load/*",
      "SaveService: Changer URLs vers /api/save/*", 
      "DeleteService: Changer URLs vers /api/delete/*",
      "PublicStoriesService: Changer URLs vers /api/load/*"
    ],
    "no_logic_changes": "Seules les URLs d'API changent, logique mÃ©tier inchangÃ©e"
  },
  "validation_checklist": [
    "âœ… Tous les endpoints migrent correctement",
    "âœ… Middleware d'authentification appliquÃ© correctement", 
    "âœ… RÃ©ponses API format identique Ã  l'existant",
    "âœ… Gestion d'erreurs robuste",
    "âœ… Pas de duplication de code",
    "âœ… Architecture cohÃ©rente et maintenable"
  ],
  "deliverables": [
    "backend/src/controllers/loadController.js",
    "backend/src/controllers/saveController.js", 
    "backend/src/controllers/deleteController.js",
    "backend/src/routes/load.routes.js",
    "backend/src/routes/save.routes.js",
    "backend/src/routes/delete.routes.js",
    "backend/src/server.js (updated)",
    "Documentation des nouveaux endpoints"
  ]
}


# ğŸ” VÃ©rification Controllers vs SchÃ©ma Prisma

## ğŸ“‹ SchÃ©ma Prisma - Rappel des modÃ¨les

### **User Model**
```prisma
model User {
  id          Int      @id @default(autoincrement())
  username    String   @unique @db.VarChar(50)
  email       String   @unique @db.VarChar(100)
  passwordHash String  @map("password_hash") @db.VarChar(255)
  description String?  @db.Text
  avatar      String?  @db.VarChar(255)
  role        UserRole @default(user)         // enum: admin, user
  createdAt   DateTime @default(now()) @map("created_at")
  
  stories     Story[]
  likes       Like[]
}
```

### **Story Model**
```prisma
model Story {
  id          Int         @id @default(autoincrement())
  title       String      @db.VarChar(200)
  content     String      @db.Text
  status      StoryStatus @default(DRAFT)    // enum: DRAFT, PUBLISHED
  userId      Int         @map("user_id")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")    // âš ï¸ AUTO-UPDATE
  publishedAt DateTime?   @map("published_at")
  
  user        User        @relation(onDelete: Cascade)     // âš ï¸ CASCADE
  likes       Like[]
}
```

### **Like Model**
```prisma
model Like {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  storyId   Int      @map("story_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  user      User     @relation(onDelete: Cascade)          // âš ï¸ CASCADE
  story     Story    @relation(onDelete: Cascade)          // âš ï¸ CASCADE
  
  @@unique([userId, storyId])                              // âš ï¸ CONTRAINTE UNIQUE
}
```

---

## âœ… **LoadController** - Correspondances vÃ©rifiÃ©es

| Endpoint | RequÃªte Prisma | Status |
|----------|----------------|--------|
| `GET /story/:id` | `prisma.story.findUnique({ where: { id }, include: { user: true } })` | âœ… Parfait |
| `GET /stats` | `prisma.story.count({ where: { userId, status: 'DRAFT' } })` | âœ… Enum correct |
| `GET /drafts` | `prisma.story.findMany({ where: { userId, status: 'DRAFT' } })` | âœ… Enum correct |
| `GET /published` | `_count: { select: { likes: true } }` | âœ… Relation likes |
| `GET /resolve/:title` | `prisma.story.findFirst({ where: { title, userId } })` | âœ… Index existant |
| `GET /latest-stories` | `orderBy: [{ publishedAt: 'desc' }]` | âœ… Champ publishedAt |
| `GET /public-story/:id` | `status: 'PUBLISHED'` + relations | âœ… Enum + relations |
| `GET /user-stories/:userId` | `prisma.story.findMany({ where: { userId, status: 'PUBLISHED' } })` | âœ… Parfait |
| `GET /user-profile/:userId` | `prisma.user.findUnique({ where: { id: userId } })` | âœ… Parfait |
| `GET /resolve-username/:username` | `prisma.user.findUnique({ where: { username } })` | âœ… Unique constraint |
| `GET /resolve-story/:username/:title` | `user: { username }` relation | âœ… Relation valide |

---

## âœ… **SaveController** - Correspondances vÃ©rifiÃ©es

| Endpoint | RequÃªte Prisma | Status |
|----------|----------------|--------|
| `POST /create` | `prisma.story.create({ data: { title, content, userId, status: 'DRAFT' } })` | âœ… Enum DRAFT |
| `PUT /story/:id` | `prisma.story.update({ where: { id }, data: { title, content } })` | âœ… Parfait |
| `POST /publish/:id` | `data: { status: 'PUBLISHED', publishedAt: new Date() }` | âœ… Enum + publishedAt |
| `POST /update/:id` | `prisma.story.update({ where: { id }, data: { title, content } })` | âš ï¸ Voir correction |
| `POST /toggle-like/:id` | `where: { userId_storyId: { userId, storyId } }` | âœ… Contrainte unique |

---

## âœ… **DeleteController** - Correspondances vÃ©rifiÃ©es

| Endpoint | RequÃªte Prisma | Status |
|----------|----------------|--------|
| `DELETE /story/:id` | `prisma.story.delete({ where: { id } })` | âš ï¸ Voir correction |

---

## ğŸš¨ **Corrections nÃ©cessaires**

### **1. SaveController - Endpoint `POST /update/:id`**

**âŒ Code actuel problÃ©matique:**
```js
await prisma.story.update({
  where: { id: originalId },
  data: {
    title: draft.title,
    content: draft.content,
    updatedAt: new Date()  // âŒ ERREUR: updatedAt est @updatedAt automatique
  }
});
```

**âœ… Code corrigÃ©:**
```js
await prisma.story.update({
  where: { id: originalId },
  data: {
    title: draft.title,
    content: draft.content
    // updatedAt se met Ã  jour automatiquement grÃ¢ce Ã  @updatedAt
  }
});
```

### **2. DeleteController - Endpoint `DELETE /story/:id`**

**âŒ Code actuel inutile:**
```js
await prisma.$transaction(async (tx) => {
  await tx.like.deleteMany({ where: { storyId: storyId } });  // âŒ INUTILE
  await tx.story.delete({ where: { id: storyId } });
});
```

**âœ… Code simplifiÃ©:**
```js
// onDelete: Cascade dans le schÃ©ma s'occupe automatiquement des likes
await prisma.story.delete({ where: { id: storyId } });
```

**Justification:** Le schÃ©ma Prisma dÃ©finit `onDelete: Cascade` sur la relation `Like -> Story`, donc Prisma supprime automatiquement tous les likes liÃ©s quand une story est supprimÃ©e.

---

## ğŸ¯ **Correspondances parfaites identifiÃ©es**

### **Enums utilisÃ©s correctement:**
- âœ… `StoryStatus.DRAFT` et `StoryStatus.PUBLISHED`
- âœ… `UserRole.admin` et `UserRole.user`

### **Relations utilisÃ©es correctement:**
- âœ… `user: { username }` pour les jointures
- âœ… `_count: { select: { likes: true } }` pour compter les likes
- âœ… `include: { user: true }` pour inclure les donnÃ©es utilisateur

### **Contraintes respectÃ©es:**
- âœ… `@@unique([userId, storyId])` pour les likes
- âœ… `@unique` sur username et email
- âœ… Cascades automatiques gÃ©rÃ©es par Prisma

### **Champs optionnels gÃ©rÃ©s:**
- âœ… `publishedAt: DateTime?` utilisÃ© correctement
- âœ… `description: String?` et `avatar: String?` gÃ©rÃ©s

---

## ğŸ“Š **Score final de correspondance**

- **LoadController**: 11/11 endpoints âœ… **100%**
- **SaveController**: 4/5 endpoints âœ… **80%** (1 correction mineure)
- **DeleteController**: 0/1 endpoints âœ… **0%** (1 correction importante)

**Score global: 15/17 = 88%** ğŸ¯

## ğŸ”§ **Actions requises**

1. **Corriger SaveController**: Supprimer `updatedAt: new Date()`
2. **Simplifier DeleteController**: Supprimer transaction inutile, utiliser cascade automatique
3. **Tester migrations**: VÃ©rifier que les cascades fonctionnent correctement

## âœ… **Conclusion**

Le schÃ©ma Prisma est **parfaitement adaptÃ©** Ã  la refactorisation. Les 2 corrections sont mineures et n'impactent pas l'architecture globale. Tous les modÃ¨les, relations et contraintes correspondent exactement aux besoins des nouveaux controllers.