{
  "task": "Refactorisation compl√®te des contr√¥leurs backend L'Antre",
  "objective": "Remplacer privateStoriesController et publicStoriesController par une architecture 1 service = 1 controller",
  "context": {
    "app": "L'Antre - Plateforme de chroniques/histoires",
    "framework": "Node.js/Express",
    "database": "SQLite avec requ√™tes SQL directes",
    "auth": "JWT middleware authenticateToken",
    "current_architecture": {
      "controllers_to_remove": [
        "privateStoriesController.js",
        "publicStoriesController.js"
      ],
      "controllers_to_keep": [
        "authController.js",
        "userController.js"
      ]
    }
  },
  "new_controllers": {
    "loadController.js": {
      "responsibility": "TOUT le chargement de donn√©es",
      "base_route": "/api/load",
      "middleware": "authenticateToken pour routes priv√©es uniquement",
      "endpoints": [
        {
          "method": "GET",
          "path": "/story/:id",
          "auth": "required",
          "source": "privateStoriesController.getStoryForEdit",
          "purpose": "Charger story pour √©dition"
        },
        {
          "method": "GET", 
          "path": "/stats",
          "auth": "required",
          "source": "privateStoriesController.getStats",
          "purpose": "Statistiques utilisateur (drafts, published, totalLikes)"
        },
        {
          "method": "GET",
          "path": "/drafts", 
          "auth": "required",
          "source": "privateStoriesController.getDrafts",
          "purpose": "Liste brouillons utilisateur"
        },
        {
          "method": "GET",
          "path": "/published",
          "auth": "required", 
          "source": "privateStoriesController.getPublishedStories",
          "purpose": "Liste histoires publi√©es utilisateur"
        },
        {
          "method": "GET",
          "path": "/resolve/:title",
          "auth": "required",
          "source": "privateStoriesController.resolveTitle", 
          "purpose": "R√©soudre titre vers ID story"
        },
        {
          "method": "GET",
          "path": "/latest-stories",
          "auth": "none",
          "source": "publicStoriesController.getLatestStories",
          "purpose": "Derni√®res histoires publiques pour page d'accueil"
        },
        {
          "method": "GET",
          "path": "/public-story/:id",
          "auth": "none", 
          "source": "publicStoriesController.getStoryById",
          "purpose": "Story publique par ID"
        },
        {
          "method": "GET",
          "path": "/user-stories/:userId",
          "auth": "none",
          "source": "publicStoriesController.getUserStories", 
          "purpose": "Toutes les stories d'un utilisateur"
        },
        {
          "method": "GET",
          "path": "/user-profile/:userId",
          "auth": "none",
          "source": "publicStoriesController.getUserProfile",
          "purpose": "Profil public utilisateur"
        },
        {
          "method": "GET", 
          "path": "/resolve-username/:username",
          "auth": "none",
          "source": "publicStoriesController.resolveUsername",
          "purpose": "R√©soudre username vers userId"
        },
        {
          "method": "GET",
          "path": "/resolve-story/:username/:title", 
          "auth": "none",
          "source": "publicStoriesController.resolveStory",
          "purpose": "R√©soudre username/title vers storyId"
        }
      ]
    },
    "saveController.js": {
      "responsibility": "TOUTE la sauvegarde/modification de donn√©es",
      "base_route": "/api/save", 
      "middleware": "authenticateToken sur toutes les routes",
      "endpoints": [
        {
          "method": "POST",
          "path": "/create",
          "source": "privateStoriesController.createDraft",
          "purpose": "Cr√©er nouveau brouillon"
        },
        {
          "method": "PUT", 
          "path": "/story/:id",
          "source": "privateStoriesController.updateDraft",
          "purpose": "Sauvegarder modifications brouillon"
        },
        {
          "method": "POST",
          "path": "/publish/:id",
          "source": "privateStoriesController.publishStory", 
          "purpose": "Publier brouillon"
        },
        {
          "method": "POST",
          "path": "/update/:id",
          "source": "privateStoriesController.updateOriginalStory",
          "purpose": "Republier story modifi√©e"
        },
        {
          "method": "POST",
          "path": "/toggle-like/:id",
          "source": "privateStoriesController.toggleLike",
          "purpose": "Liker/unliker story publique"
        }
      ]
    },
    "deleteController.js": {
      "responsibility": "TOUTE la suppression de donn√©es", 
      "base_route": "/api/delete",
      "middleware": "authenticateToken sur toutes les routes",
      "endpoints": [
        {
          "method": "DELETE",
          "path": "/story/:id",
          "source": "privateStoriesController.deleteStory",
          "purpose": "Supprimer story (brouillon ou publi√©e)"
        }
      ]
    }
  },
  "technical_specs": {
    "code_style": {
      "quality": "Senior level - simple, robuste, efficace", 
      "separators": "//============ SECTION ============",
      "naming": "Noms logiques, pas d'inventions",
      "error_handling": "try/catch avec messages d'erreur clairs",
      "responses": "Format JSON consistant { message, data, error }",
      "no_logs": "Pas de console.log parasites"
    },
    "route_structure": {
      "pattern": "router.METHOD('/path', middleware, controller.method)",
      "middleware_usage": "authenticateToken uniquement o√π n√©cessaire",
      "parameter_validation": "Validation basique req.params, req.body"
    },
    "database": {
      "type": "SQLite",
      "queries": "SQL direct, pas d'ORM",
      "connection": "Utiliser db existant import√©",
      "transactions": "Pour op√©rations critiques uniquement"
    }
  },
  "migration_steps": {
    "step_1": "Cr√©er loadController.js avec tous les endpoints de chargement",
    "step_2": "Cr√©er saveController.js avec tous les endpoints de sauvegarde", 
    "step_3": "Cr√©er deleteController.js avec endpoint de suppression",
    "step_4": "Mettre √† jour les routes dans server.js",
    "step_5": "Tester tous les endpoints",
    "step_6": "Supprimer privateStoriesController.js et publicStoriesController.js"
  },
  "routes_update": {
    "server.js_changes": [
      "app.use('/api/load', require('./routes/load.routes'));",
      "app.use('/api/save', require('./routes/save.routes'));", 
      "app.use('/api/delete', require('./routes/delete.routes'));"
    ],
    "routes_to_remove": [
      "app.use('/api/private-stories', require('./routes/privateStories.routes'));",
      "app.use('/api/public-stories', require('./routes/publicStories.routes'));"
    ]
  },
  "frontend_impact": {
    "services_to_update": [
      "LoadService: Changer URLs vers /api/load/*",
      "SaveService: Changer URLs vers /api/save/*", 
      "DeleteService: Changer URLs vers /api/delete/*",
      "PublicStoriesService: Changer URLs vers /api/load/*"
    ],
    "no_logic_changes": "Seules les URLs d'API changent, logique m√©tier inchang√©e"
  },
  "validation_checklist": [
    "‚úÖ Tous les endpoints migrent correctement",
    "‚úÖ Middleware d'authentification appliqu√© correctement", 
    "‚úÖ R√©ponses API format identique √† l'existant",
    "‚úÖ Gestion d'erreurs robuste",
    "‚úÖ Pas de duplication de code",
    "‚úÖ Architecture coh√©rente et maintenable"
  ],
  "deliverables": [
    "backend/src/controllers/loadController.js",
    "backend/src/controllers/saveController.js", 
    "backend/src/controllers/deleteController.js",
    "backend/src/routes/load.routes.js",
    "backend/src/routes/save.routes.js",
    "backend/src/routes/delete.routes.js",
    "backend/src/server.js (updated)",
    "Documentation des nouveaux endpoints"
  ]
}


# üîç V√©rification Controllers vs Sch√©ma Prisma

## üìã Sch√©ma Prisma - Rappel des mod√®les

### **User Model**
```prisma
model User {
  id          Int      @id @default(autoincrement())
  username    String   @unique @db.VarChar(50)
  email       String   @unique @db.VarChar(100)
  passwordHash String  @map("password_hash") @db.VarChar(255)
  description String?  @db.Text
  avatar      String?  @db.VarChar(255)
  role        UserRole @default(user)         // enum: admin, user
  createdAt   DateTime @default(now()) @map("created_at")
  
  stories     Story[]
  likes       Like[]
}
```

### **Story Model**
```prisma
model Story {
  id          Int         @id @default(autoincrement())
  title       String      @db.VarChar(200)
  content     String      @db.Text
  status      StoryStatus @default(DRAFT)    // enum: DRAFT, PUBLISHED
  userId      Int         @map("user_id")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")    // ‚ö†Ô∏è AUTO-UPDATE
  publishedAt DateTime?   @map("published_at")
  
  user        User        @relation(onDelete: Cascade)     // ‚ö†Ô∏è CASCADE
  likes       Like[]
}
```

### **Like Model**
```prisma
model Like {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  storyId   Int      @map("story_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  user      User     @relation(onDelete: Cascade)          // ‚ö†Ô∏è CASCADE
  story     Story    @relation(onDelete: Cascade)          // ‚ö†Ô∏è CASCADE
  
  @@unique([userId, storyId])                              // ‚ö†Ô∏è CONTRAINTE UNIQUE
}
```

---

## ‚úÖ **LoadController** - Correspondances v√©rifi√©es

| Endpoint | Requ√™te Prisma | Status |
|----------|----------------|--------|
| `GET /story/:id` | `prisma.story.findUnique({ where: { id }, include: { user: true } })` | ‚úÖ Parfait |
| `GET /stats` | `prisma.story.count({ where: { userId, status: 'DRAFT' } })` | ‚úÖ Enum correct |
| `GET /drafts` | `prisma.story.findMany({ where: { userId, status: 'DRAFT' } })` | ‚úÖ Enum correct |
| `GET /published` | `_count: { select: { likes: true } }` | ‚úÖ Relation likes |
| `GET /resolve/:title` | `prisma.story.findFirst({ where: { title, userId } })` | ‚úÖ Index existant |
| `GET /latest-stories` | `orderBy: [{ publishedAt: 'desc' }]` | ‚úÖ Champ publishedAt |
| `GET /public-story/:id` | `status: 'PUBLISHED'` + relations | ‚úÖ Enum + relations |
| `GET /user-stories/:userId` | `prisma.story.findMany({ where: { userId, status: 'PUBLISHED' } })` | ‚úÖ Parfait |
| `GET /user-profile/:userId` | `prisma.user.findUnique({ where: { id: userId } })` | ‚úÖ Parfait |
| `GET /resolve-username/:username` | `prisma.user.findUnique({ where: { username } })` | ‚úÖ Unique constraint |
| `GET /resolve-story/:username/:title` | `user: { username }` relation | ‚úÖ Relation valide |

---

## ‚úÖ **SaveController** - Correspondances v√©rifi√©es

| Endpoint | Requ√™te Prisma | Status |
|----------|----------------|--------|
| `POST /create` | `prisma.story.create({ data: { title, content, userId, status: 'DRAFT' } })` | ‚úÖ Enum DRAFT |
| `PUT /story/:id` | `prisma.story.update({ where: { id }, data: { title, content } })` | ‚úÖ Parfait |
| `POST /publish/:id` | `data: { status: 'PUBLISHED', publishedAt: new Date() }` | ‚úÖ Enum + publishedAt |
| `POST /update/:id` | `prisma.story.update({ where: { id }, data: { title, content } })` | ‚ö†Ô∏è Voir correction |
| `POST /toggle-like/:id` | `where: { userId_storyId: { userId, storyId } }` | ‚úÖ Contrainte unique |

---

## ‚úÖ **DeleteController** - Correspondances v√©rifi√©es

| Endpoint | Requ√™te Prisma | Status |
|----------|----------------|--------|
| `DELETE /story/:id` | `prisma.story.delete({ where: { id } })` | ‚ö†Ô∏è Voir correction |

---

## üö® **Corrections n√©cessaires**

### **1. SaveController - Endpoint `POST /update/:id`**

**‚ùå Code actuel probl√©matique:**
```js
await prisma.story.update({
  where: { id: originalId },
  data: {
    title: draft.title,
    content: draft.content,
    updatedAt: new Date()  // ‚ùå ERREUR: updatedAt est @updatedAt automatique
  }
});
```

**‚úÖ Code corrig√©:**
```js
await prisma.story.update({
  where: { id: originalId },
  data: {
    title: draft.title,
    content: draft.content
    // updatedAt se met √† jour automatiquement gr√¢ce √† @updatedAt
  }
});
```

### **2. DeleteController - Endpoint `DELETE /story/:id`**

**‚ùå Code actuel inutile:**
```js
await prisma.$transaction(async (tx) => {
  await tx.like.deleteMany({ where: { storyId: storyId } });  // ‚ùå INUTILE
  await tx.story.delete({ where: { id: storyId } });
});
```

**‚úÖ Code simplifi√©:**
```js
// onDelete: Cascade dans le sch√©ma s'occupe automatiquement des likes
await prisma.story.delete({ where: { id: storyId } });
```

**Justification:** Le sch√©ma Prisma d√©finit `onDelete: Cascade` sur la relation `Like -> Story`, donc Prisma supprime automatiquement tous les likes li√©s quand une story est supprim√©e.

---

## üéØ **Correspondances parfaites identifi√©es**

### **Enums utilis√©s correctement:**
- ‚úÖ `StoryStatus.DRAFT` et `StoryStatus.PUBLISHED`
- ‚úÖ `UserRole.admin` et `UserRole.user`

### **Relations utilis√©es correctement:**
- ‚úÖ `user: { username }` pour les jointures
- ‚úÖ `_count: { select: { likes: true } }` pour compter les likes
- ‚úÖ `include: { user: true }` pour inclure les donn√©es utilisateur

### **Contraintes respect√©es:**
- ‚úÖ `@@unique([userId, storyId])` pour les likes
- ‚úÖ `@unique` sur username et email
- ‚úÖ Cascades automatiques g√©r√©es par Prisma

### **Champs optionnels g√©r√©s:**
- ‚úÖ `publishedAt: DateTime?` utilis√© correctement
- ‚úÖ `description: String?` et `avatar: String?` g√©r√©s

---

## üìä **Score final de correspondance**

- **LoadController**: 11/11 endpoints ‚úÖ **100%**
- **SaveController**: 4/5 endpoints ‚úÖ **80%** (1 correction mineure)
- **DeleteController**: 0/1 endpoints ‚úÖ **0%** (1 correction importante)

**Score global: 15/17 = 88%** üéØ

## üîß **Actions requises**

1. **Corriger SaveController**: Supprimer `updatedAt: new Date()`
2. **Simplifier DeleteController**: Supprimer transaction inutile, utiliser cascade automatique
3. **Tester migrations**: V√©rifier que les cascades fonctionnent correctement

## ‚úÖ **Conclusion**

Le sch√©ma Prisma est **parfaitement adapt√©** √† la refactorisation. Les 2 corrections sont mineures et n'impactent pas l'architecture globale. Tous les mod√®les, relations et contraintes correspondent exactement aux besoins des nouveaux controllers.